import { getDateString, cleanString } from './utils';

const getHeaderStart = (): string => `/*
 * This file was generated by CSS 2 JUCE.
 * Do not modify this file, as your changes will likely be overwritten!
 *
 * Author: Tr√© Dudman
 * Github: https://github.com/Tremus
 * Repo: https://github.com/Tremus/CSS2JUCE
 * Last Compiled At: ${getDateString()}
 */

#pragma once
#include <JuceHeader.h>

namespace GUI
{
namespace Dimensions
{
`;

const HEADER_END = `
} // end namespace Dimensions

} // end namespace GUI`;

class Rectangle {
    name: string;
    x: number;
    y: number;
    width: number;
    height: number;
    children: Array<Rectangle>;

    constructor(_name: string, _x: number, _y: number, _width: number, _height: number) {
        this.name = cleanString(_name);
        this.x = Math.round(_x);
        this.y = Math.round(_y);
        this.width = Math.round(_width);
        this.height = Math.round(_height);
        this.children = [];
    }

    // recursively translates x/y position
    translateChildren(): void {
        for (let i = 0; i < this.children.length; i++) {
            let child = this.children[i];
            // recursion
            child.translateChildren();
            // This must come after calling child.translateChildren()
            // That way children will start from 0, rather than the parents
            // deducting 0 from their children
            child.x -= this.x;
            child.y -= this.y;
        }
    }
    toString(): string {
        let text = '';
        text += `namespace ${this.name}\n`;
        text += '{\n';
        text += `const juce::Rectangle<float> Bounds { ${this.x}.0f, ${this.y}.0f, ${this.width}.0f, ${this.height}.0f };\n`;

        for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            text += child.toString();
        }

        text += `} // end namespace ${this.name}\n`;

        return text;
    }
}

const parseToRectangle = (node: SceneNode): Rectangle => {
    const rect = new Rectangle(node.name, node.x, node.y, node.width, node.height);

    if ('children' in node) {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const nextRect = parseToRectangle(child);
            rect.children.push(nextRect);
        }
    }
    return rect;
};

const runBounds = (): void => {
    const selection = figma.currentPage.selection;

    let text = '';
    text += getHeaderStart();
    for (let [idx, listItem] of selection.entries()) {
        let rect = parseToRectangle(listItem);
        rect.translateChildren();

        text += rect.toString();
    }
    text += HEADER_END;

    figma.ui.postMessage({ type: 'output', payload: { name: 'Dimensions.h', text } });
};

export default runBounds;
