import { getDateString, cleanString } from './utils';

type TextFile = {
    name: string;
    body: string;
};

export type TextFiles = Array<TextFile>;

const getHeaderStart = (
    compilationTime: string,
): string => `// Autogenerated by CSS 2 JUCE (see: https://github.com/Tremus/CSS2JUCE)
#pragma once
#include <juce_core/juce_core.h>
namespace CSS2JUCE {`;

const HEADER_END = `}\n`;

const getFile = (compilationTime: string, content: string): string =>
    `${getHeaderStart(compilationTime)}${content}${HEADER_END}`;

const isNameValid = (name: string): boolean => !name.startsWith('_');

class Rectangle {
    name: string;
    x: number;
    y: number;
    width: number;
    height: number;
    children: Array<Rectangle>;

    constructor(_name: string, _x: number, _y: number, _width: number, _height: number) {
        this.name = cleanString(_name);
        this.x = Math.round(_x);
        this.y = Math.round(_y);
        this.width = Math.round(_width);
        this.height = Math.round(_height);
        this.children = [];
    }

    // recursively translates x/y position
    translateChildren(): void {
        for (let i = 0; i < this.children.length; i++) {
            let child = this.children[i];
            // recursion
            child.translateChildren();
            // This must come after calling child.translateChildren()
            // That way children will start from 0, rather than the parents
            // deducting 0 from their children
            child.x -= this.x;
            child.y -= this.y;
        }
    }
    toString = (): string =>
        `const juce::Rectangle<float> ${this.name} { ${this.x}.0f, ${this.y}.0f, ${this.width}.0f, ${this.height}.0f };`;

    addFile(files: Array<TextFile>, compilationTime: string): void {
        files.push({
            name: `${this.name}.h`,
            body: getFile(compilationTime, this.toString()),
        });
        for (const child of this.children) {
            child.addFile(files, compilationTime);
        }
    }
}

const parseToRectangle = (prefix: string, node: SceneNode): Rectangle => {
    const rect = new Rectangle(prefix + node.name, node.x, node.y, node.width, node.height);

    if ('children' in node) {
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];

            if (!isNameValid(child.name)) continue;

            const nextRect = parseToRectangle(rect.name + '_', child);
            rect.children.push(nextRect);
        }
    }
    return rect;
};

const runBounds = (): void => {
    const selection = figma.currentPage.selection;
    const compilationTime = getDateString();

    let files: Array<TextFile> = [];

    for (let [idx, listItem] of selection.entries()) {
        let rect = parseToRectangle('', listItem);
        rect.translateChildren();

        rect.addFile(files, compilationTime);
    }

    figma.ui.postMessage({ type: 'zip', payload: files });
};

export default runBounds;
